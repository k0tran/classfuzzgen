/// This file is autogenerated
/// Base jinja2 harness function template without any special mutators

#include "{{ class_header }}"

#include <cstdint>
#include <iterator> // for std::size

// Constructor section

struct ConstrData {
    size_t arg_size;
    {{ class_name }} (*fn)(const uint8_t *);
};
{% for c in constructors %}
{{ class_name }} constr_{{ loop.index }}(const uint8_t *data) {
{% if length(c) == 0 %}
    return {{ class_name }}();
{% else %}
    size_t size = 0;

    // args
    {% for a in c %}
    {{ a }} *arg_{{ loop.index }} = ({{ a }} *)(data + size);
    size += sizeof({{ a }});
    {% endfor %}

    // call
    return {{ class_name }}({% for a in c %}{% if loop.index != 0 %}, {% endif %}*arg_{{loop.index}}{% endfor %});
{% endif %}
}
{% endfor %}
const ConstrData constr_list[] = {
    {% for c in constructors %}
    {
        .arg_size = 0{% for i in c %} + sizeof({{ i }}){% endfor %},
        .fn = constr_{{ loop.index }},
    },
    {% endfor %}
};

constexpr size_t constr_size = std::size(constr_list);

// Method section

struct MethodData {
    size_t arg_size;
    void (*fn)({{ class_name }} *, const uint8_t *);
};
{% for m in methods %}
void method_{{ m.name }}({{ class_name }} *obj, const uint8_t *data) {
{% if length(m.args) == 0 %}
    // call
    obj->{{ m.name }}();
{% else %}
    size_t size = 0;

    // args
    {% for a in m.args %}
    {{ a }} *arg_{{ loop.index }} = ({{ a }} *)(data + size);
    size += sizeof({{ a }});
    {% endfor %}

    // call
    obj->{{ m.name }}({% for a in m.args %}{% if loop.index != 0 %}, {% endif %}*arg_{{ loop.index }}{% endfor %});
{% endif %}
}
{% endfor %}
const MethodData method_list[] = {
    {% for m in methods %}
    {
        .arg_size = 0{% for i in m.args %} + sizeof({{ i }}){% endfor %},
        .fn = method_{{ m.name }},
    },
    {% endfor %}
};
constexpr size_t method_size = std::size(method_list);


extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    // supported up to 255 constructors and methods

    // empty string
    if (size == 0)
        return 0;

    // get constr id
    size_t args = 0;
    auto c = constr_list[data[args] % constr_size];
    args += 1;

    // check if we have enough space for arguments
    if (args + c.arg_size > size)
        return 0;

    // call constructor
    auto obj = c.fn(data + args);
    args += c.arg_size;

    // check if we have enough space for method id
    if (args >= size)
        return 0;

    // get method
    auto m = method_list[data[args] % method_size];
    args += 1;

    while (args + m.arg_size <= size) {
        // call method
        m.fn(&obj, data + args);
        args += m.arg_size;

        // check if we have space for another method
        if (args >= size)
            return 0;

        // get new method
        m = method_list[data[args] % method_size];
        args += 1;
    }

    return 0;
}
