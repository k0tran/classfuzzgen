/// This file is autogenerated
/// jinja2 harness function template with mutations

#include "{{ class_header }}"

#include <cstdint>
#include <iterator> // for std::size
#include <random>

// CONSTRUCTORS

struct ConstrData {
    size_t arg_size;
    {{ class_name }} (*fn)(const uint8_t *);
};

// Wrappers
{% for c in constructors %}
{{ class_name }} constr_{{ loop.index }}(const uint8_t *data) {
{% if length(c) == 0 %}    return {{ class_name }}();
{% else %}    size_t size = 0;

    {% for a in c -%}
    {{ a }} *arg_{{ loop.index }} = ({{ a }} *)(data + size);
    size += sizeof({{ a }});{% endfor %}

    return {{ class_name }}({% for a in c %}{% if loop.index != 0 %}, {% endif %}*arg_{{loop.index}}{% endfor %});
{% endif %}}
{% endfor %}
// List

const ConstrData constr_list[] = {
    {% for c in constructors -%}
    {
        .arg_size = 0{% for i in c %} + sizeof({{ i }}){% endfor %},
        .fn = constr_{{ loop.index }},
    },{% endfor %}
};

constexpr size_t constr_size = std::size(constr_list);

// METHODS

struct MethodData {
    size_t arg_size;
    void (*fn)({{ class_name }} *, const uint8_t *);
};

// Wrappers
{% for m in methods %}
void method_{{ m.name }}({{ class_name }} *obj, const uint8_t *data) {
{% if length(m.args) == 0 %}    obj->{{ m.name }}();
{% else %}    size_t size = 0;

    {% for a in m.args -%}
    {{ a }} *arg_{{ loop.index }} = ({{ a }} *)(data + size);
    size += sizeof({{ a }});{% endfor %}

    obj->{{ m.name }}({% for a in m.args %}{% if loop.index != 0 %}, {% endif %}*arg_{{ loop.index }}{% endfor %});
{% endif %}}
{% endfor %}
// List

const MethodData method_list[] = {
    {% for m in methods -%}
    {
        .arg_size = 0{% for i in m.args %} + sizeof({{ i }}){% endfor %},
        .fn = method_{{ m.name }},
    },{% endfor %}
};

constexpr size_t method_size = std::size(method_list);

// CALL CHAIN

extern "C" size_t LLVMFuzzerMutate(uint8_t *Data, size_t Size, size_t MaxSize);

class CallChain {
public:
    static const size_t MAX_LEN = 10;

    static uint eval(const uint8_t *data, size_t size) {
        if (size == 0)
            return 1;
        
        size_t ptr = 0;
        auto c = constr_list[data[ptr] % constr_size];
        ptr++;

        if (ptr + c.arg_size > size)
            return 1;

        auto obj = c.fn(data + ptr);
        ptr += c.arg_size;

        if (ptr >= size)
            return 1;

        auto m = method_list[data[ptr] % method_size];
        ptr++;

        while (ptr + m.arg_size <= size) {
            m.fn(&obj, data + ptr);
            ptr += m.arg_size;

            if (ptr >= size)
                return 1;

            m = method_list[data[ptr] % method_size];
            ptr++;
        }

        return 0;
    }

    // Assuming data is not null and size != 0
    CallChain(uint8_t *d, size_t s) : data(d), size(s) {
        len = 0;
        calls[len] = constr_list[data[0] % constr_size].arg_size + 1;
        
        while (len < MAX_LEN - 1 && calls[len] < size) {
            len++;
            calls[len] = calls[len - 1] + method_list[data[calls[len - 1]] % method_size].arg_size + 1;
        }

        len++;
    }

    // Remove method
    size_t delete_call(size_t cid) {
        cid %= len;
        if (cid == 0)
            return size;
        
        size_t shift = calls[cid] - calls[cid - 1];
        for (size_t i = calls[cid - 1]; i + shift < size; ++i)
            data[i] = data[i + shift];
        size -= shift;
        
        for (size_t i = cid; i < len - 1; ++i)
            calls[cid] = calls[cid + 1];
        len--;

        return size;
    }

    // Add method
    size_t insert_call(size_t cid, size_t place, size_t max_size) {
        cid %= method_size;
        place %= len;

        size_t shift = method_list[cid].arg_size + 1;

        if (size + shift > max_size || len + 1 > MAX_LEN)
            return size;
        
        for (size_t i = size + shift - 1; i > calls[cid] + shift; --i)
            data[i] = data[i - 1];
        
        for (size_t i = cid + 1; i < len; ++i)
            calls[i] += shift;
        
        for (size_t i = calls[cid]; i < calls[cid + 1]; ++i)
            data[i] = 0;
        
        len++;
        size += shift;
        return size;
    }

    // Change constructor
    size_t change_constructor(size_t cid, size_t max_size) {
        cid %= constr_size;
        size_t shift = constr_list[cid].arg_size + 1 - calls[0];

        if (size + shift > max_size)
            return size;

        for (size_t i = 0; i < calls[0] + shift; ++i)
            data[i] = 0;

        if (shift < 0){
            for (size_t i = calls[0] + shift; i < size + shift; ++i)
                data[i] = data[i + 1];
            size += shift;
        } else {
            for (size_t i = calls[0]; i < size + shift; ++i)
                data[i] = data[i + 1];
            size += shift;
        }

        for (size_t i = 0; i < len; ++i)
            calls[i] += shift;
        
        return size;
    }

    // // Mutate all arguments at once
    // size_t mutate_args(size_t cid) {
    //     cid %= len;
    //     std::cout << calls[cid] + 1 << " " << calls[cid] - calls[cid + 1] << " " << calls[cid + 1] << std::endl << std::endl;
    //     LLVMFuzzerMutate(data + calls[cid] + 1, calls[cid + 1] - calls[cid], calls[cid + 1] - calls[cid]);
    //     return size;
    // }

private:
    uint8_t *data;
    size_t size;

    size_t calls[MAX_LEN];
    size_t len;
};

// MUTATORS

extern "C" size_t LLVMFuzzerCustomMutator(uint8_t *Data, size_t Size, size_t MaxSize, unsigned int Seed) {
    if (Size == 0)
        return 0;

    CallChain c(Data, Size);

    std::mt19937 rng(Seed);
    switch (rng() % 4) {
        case 0:
            return c.delete_call(rng());
        case 1: 
            return c.insert_call(rng(), rng(), MaxSize);
        case 2: 
            return c.change_constructor(rng(), MaxSize);
        case 3:
            // return c.mutate_args(rng()); TODO: fix errors
        default: 
            return Size;
    }
}

// TODO: crossing over
// extern "C" size_t LLVMFuzzerCustomCrossOver(
//     const uint8_t *Data1, size_t Size1,
//     const uint8_t *Data2, size_t Size2,
//     uint8_t *Out, size_t MaxOutSize,
//     unsigned int Seed
// ) {
//     CallChain c1(Data1, Size1), c2(Data2, Size2);
// }

// HARNESS FN

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    CallChain::eval(data, size);
    return 0;
}
