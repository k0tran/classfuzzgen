/// This file is autogenerated

#include "{{ class_header }}"

#include <cstdint>
#include <iterator> // for std::size
#include <random>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <CLI11.hpp>

/// ------------------------------ DUMPED DATA ------------------------------

namespace target {

struct Argument {
    bool is_pointer;
    size_t size;
    const char *tname;
};

const size_t ARG_LIMIT = {{ arg_limit }};

struct AData {
    Argument list[ARG_LIMIT];
    size_t size;
    size_t bytesize;
};

/// -------------- CONSTRUCTORS --------------

struct CData {
    AData args;
    {{ class_name }} (*fn)(const uint8_t *);
};

{% for c in constructors %}
{{ class_name }} constr_{{ loop.index }}(const uint8_t *data) {
{% if length(c.args) == 0 %}    return {{ class_name }}();
{% else %}    size_t size = 0;

    {% for a in c.args -%}
    {{ a.name }} *arg_{{ loop.index }} = ({{ a.name }} *)(data + size);
    size += sizeof({{ a.name }});{% endfor %}

    return {{ class_name }}({% for a in c.args %}{% if loop.index != 0 %}, {% endif %}*arg_{{loop.index}}{% endfor %});
{% endif %}{{ "};" }}
{% endfor %}

const CData c_list[] = {
    {% for c in constructors -%}
    {
        .args = {
            .list = {
                {% for a in c.args %}{{ "{" }}{{ a.is_pointer }}, sizeof({{ a.name }}), "{{ a.name }}"},{% endfor %}
            },
            .size = {{ length(c.args) }},
            .bytesize = 0{% for a in c.args %} + sizeof({{ a.name }}){% endfor %},
        },
        .fn = constr_{{ loop.index }},
    },{% endfor %}
};

constexpr size_t c_size = std::size(c_list);

/// -------------- METHODS --------------

struct MData {
    AData args;
    const char *name;
    void (*fn)({{ class_name }} *, const uint8_t *);
};

{% for m in methods %}
void method_{{ loop.index }}({{ class_name }} *obj, const uint8_t *data) {
{% if length(m.args) == 0 %}    obj->{{ m.name }}();
{% else %}    size_t size = 0;

    {% for a in m.args -%}
    {{ a.name }} *arg_{{ loop.index }} = ({{ a.name }} *)(data + size);
    size += sizeof({{ a.name }});{% endfor %}

    obj->{{ m.name }}({% for a in m.args %}{% if loop.index != 0 %}, {% endif %}*arg_{{ loop.index }}{% endfor %});
{% endif %}{{ "};"}}
{% endfor %}

const MData m_list[] = {
    {% for m in methods -%}
    {
        .args = {
            .list = {
                {% for a in m.args %}{{ "{" }}{{ a.is_pointer }}, sizeof({{ a.name }}), "{{ a.name }}"},{% endfor %}
            },
            .size = {{ length(m.args) }},
            .bytesize = 0{% for a in m.args %} + sizeof({{ a.name }}){% endfor %},
        },
        .name = "{{ m.name }}",
        .fn = method_{{ loop.index }},
    },{% endfor %}
};

constexpr size_t m_size = std::size(m_list);

} // namespace

/// ------------------------------ CALL CHAIN AND MUTATOR ------------------------------

class CallChain {
public:
    static const size_t LIMIT = {{ cc_limit }};

    static int eval(const uint8_t *data, size_t size) {
        if (size == 0)
            return 1;
        
        size_t ptr = 0;
        auto c = target::c_list[data[ptr] % target::c_size];
        ptr++;

        if (ptr + c.args.bytesize > size)
            return 1;

        auto obj = c.fn(data + ptr);
        ptr += c.args.bytesize;

        if (ptr >= size)
            return 1;

        auto m = target::m_list[data[ptr] % target::m_size];
        ptr++;

        size_t i = 0;
        while (ptr + m.args.bytesize <= size && i++ < LIMIT) {
            m.fn(&obj, data + ptr);
            ptr += m.args.bytesize;

            if (ptr >= size)
                return 1;

            m = target::m_list[data[ptr] % target::m_size];
            ptr++;
        }

        return 0;
    }

    CallChain(const uint8_t *data, size_t size) : d1(data), d2(nullptr), d_size(size) { update_chain(); }

    CallChain(uint8_t * data, size_t size) : d1(data), d2(data), d_size(size) { update_chain(); }

    size_t get_call_start_idx(size_t n) {
        if (n == 0)
            return 0;
        return calls[n - 1];
    }

    size_t get_cid(size_t n) const {
        if (n == 0)
            return d1[0] % target::c_size;
        return d1[calls[n - 1]] % target::m_size;
    }

    size_t get_size() const {
        return calls_size;
    }

    size_t get_arg_offset(size_t n, size_t a) const {
        size_t offset = n == 0 ? 1 : calls[n - 1] + 1;
        size_t cid = get_cid(n);
        const target::AData &ad = n == 0 ? target::c_list[cid].args : target::m_list[cid].args;

        if (a > ad.size)
            return 0;

        for (size_t i = 0; i < a; ++i)
            offset += ad.list[i].size;
        
        return offset;
    }

    const uint8_t *get_arg_ptr(size_t n, size_t a) const {
        size_t offset = get_arg_offset(n, a);
        if (offset == 0) // impossible cause first is always constructor id
            return nullptr;
        
        return d1 + offset;
    }

    size_t remove_call(size_t n) {
        n %= calls_size;
        if (d2 == nullptr || n == 0)
            return d_size;

        size_t shift = calls[n] - calls[n - 1];
        for (size_t i = calls[n - 1]; i < d_size - shift; ++i)
            d2[i] = d2[i + shift];
        d_size -= shift;

        update_chain();
        
        return d_size;
    }

    size_t insert_call(size_t cid, size_t n, size_t max_size) {
        cid %= target::m_size;
        n %= (calls_size + 1);
        if (d2 == nullptr || n == 0 || calls_size >= LIMIT)
            return d_size;

        size_t shift = target::m_list[cid].args.bytesize + 1;
        if (d_size + shift > max_size)
            return d_size;
        
        for (size_t i = d_size - 1; i >= calls[n - 1]; --i)
            d2[i + shift] = d2[i];

        d2[calls[n - 1]] = cid;
        for (size_t i = 1; i < shift; ++i)
            d2[calls[n - 1] + i] = 0;
        d_size += shift;

        update_chain();

        return d_size;
    }

    size_t mutate_args(size_t n) {
        if (d2 == nullptr)
            return d_size;
        
        uint8_t *data = d2 + calls[n - 1] + 1;
        size_t size = calls[n] - calls[n - 1];

        // Simulate libfuzzer modifications
        for (size_t i = 0; i < size; ++i)
            data[i] = 'a';

        return d_size;
    }

private:
    const uint8_t *d1;
    uint8_t *d2;
    size_t d_size;

    size_t calls[LIMIT];
    size_t calls_size;

    void update_chain() {
        if (d_size == 0) {
            calls_size = 0;
            return;
        }

        if (d2 != nullptr && d1 != d2)
            d1 = d2;
        
        calls[0] = target::c_list[d1[0] % target::c_size].args.bytesize + 1;
        calls_size = 1;

        while (calls_size < LIMIT && calls[calls_size - 1] < d_size) {
            calls[calls_size] = calls[calls_size - 1] + target::m_list[d1[calls[calls_size - 1]] % target::m_size].args.bytesize + 1;
            calls_size++;
        }
    }
};

/// ------------------------------ COMMANDS ------------------------------

void print_data_as_hex(const uint8_t *data, size_t size) {
    for (int i = 0; i < size; ++i)
        std::cout << std::hex << std::setfill('0') << std::setw(2) << (int)data[i] << " ";
}

void print_cc(const CallChain &cc) {
    std::cout << cc.get_size() << " calls:" << std::endl;

    size_t cid = cc.get_cid(0);
    std::cout << "{{ class_name }}(";

    size_t n = target::c_list[cid].args.size;
    if (n == 0)
        std::cout << ")" << std::endl;
    else {
        for (size_t i = 0; i < n; ++i){
            std::cout << std::endl << "    " << target::c_list[cid].args.list[i].tname << " : ";
            print_data_as_hex(cc.get_arg_ptr(0, i), target::c_list[cid].args.list[i].size);
            std::cout << std::endl;
        }
        std::cout << ")" << std::endl;
    }

    for (size_t i = 1; i < cc.get_size(); ++i) {
        cid = cc.get_cid(i);
        std::cout << target::m_list[cid].name << "(";
        
        n = target::m_list[cid].args.size;
        if (n == 0)
            std::cout << ")" << std::endl;
        else {
            for (size_t j = 0; j < n; ++j){
                std::cout << std::endl << "    " << target::m_list[cid].args.list[j].tname << " : ";
                print_data_as_hex(cc.get_arg_ptr(i, j), target::m_list[cid].args.list[j].size);
                std::cout << std::endl;
            }
            std::cout << ")" << std::endl;
        }
    }
}

extern "C" size_t crossover(
    const uint8_t *data1, size_t size1,
    const uint8_t *data2, size_t size2,
    uint8_t *out, size_t max_out_size,
    size_t p1, 
    size_t p2
) {
    CallChain c1(data1, size1), c2(data2, size2);

    if (c1.get_size() == 0 || c2.get_size() == 0) {
        for (size_t i = 0; i < max_out_size; ++i)
            out[i] = 0;
        return max_out_size;
    }

    p1 %= c1.get_size();
    p2 %= c2.get_size();
    
    size_t i;
    for (i = 0; i < c1.get_call_start_idx(p1); ++i)
        out[i] = data1[i];
    
    for (size_t j = c2.get_call_start_idx(p2); j < size2; ++j, ++i)
        out[i] = data2[j];
    
    return i;
}

/// ------------------------------ MAIN FN ------------------------------

const size_t MUTATION_RESERVE = 10;

std::tuple<uint8_t *, size_t> load_file(const std::string &filename) {
    std::ifstream ifs(filename);
    if (!ifs)
        return std::make_tuple(nullptr, 0);

    ifs.seekg(0, std::ios_base::end);
    std::streamsize size = ifs.tellg();
    ifs.seekg(0, std::ios_base::beg);

    uint8_t *data = new uint8_t[size + MUTATION_RESERVE];
    if (!ifs.read(reinterpret_cast<char*>(data), size)) {
        delete [] data;
        return std::make_tuple(nullptr, 0);
    }

    return std::make_tuple(data, size);
}

int main(int argc, char **argv) {
    CLI::App app("CallChain editor");
    argv = app.ensure_utf8(argv);

    std::string file1;

    CLI::App *print_cmd = app.add_subcommand("print", "Print CallChain");
    print_cmd->add_option("-f,--file", file1, "File to read CC from")->check(CLI::ExistingFile)->required();

    std::string file2;
    size_t p1, p2;
    CLI::App *crossover_cmd = app.add_subcommand("crossover", "Crossover two chains");
    crossover_cmd->add_option("--f1", file1, "First file to read from")->check(CLI::ExistingFile)->required();
    crossover_cmd->add_option("--f2", file2, "Second file to read from")->check(CLI::ExistingFile)->required();
    crossover_cmd->add_option("--p1", p1, "Point to cut off first chain")->required();
    crossover_cmd->add_option("--p2", p2, "Point to continue from the second chain")->required();

    CLI::App *remove_call_cmd = app.add_subcommand("rmc", "Remove method from chain");
    remove_call_cmd->add_option("-f,--file", file1, "File to read CC from")->check(CLI::ExistingFile)->required();
    remove_call_cmd->add_option("-n", p1, "N of the removing method")->required();

    CLI::App *insert_call_cmd = app.add_subcommand("ins", "Insert new method to the chain (args get zeroed)");
    insert_call_cmd->add_option("-f,--file", file1, "File to read CC from")->check(CLI::ExistingFile)->required();
    insert_call_cmd->add_option("-n", p1, "Place to insert new method")->required();
    insert_call_cmd->add_option("-c", p2, "New method id")->required();

    CLI::App *mutate_args_cmd = app.add_subcommand("muta", "Set all arguments of call to 'a'");
    mutate_args_cmd->add_option("-f,--file", file1, "File to read CC from")->check(CLI::ExistingFile)->required();
    mutate_args_cmd->add_option("-n", p1, "N of the modified method")->required();
    
    app.require_subcommand(1);

    CLI11_PARSE(app, argc, argv);

    uint8_t *data; size_t size;
    std::tie(data, size) = load_file(file1);
    if (size == 0) {
        delete [] data;
        return 1;
    }
    CallChain cc(data, size);

    if (cc.get_size() == 0) {
        std::cout << "Found an empty chain" << std::endl;
        delete [] data;
        return 0;
    }

    if (app.got_subcommand(print_cmd)) {
        print_cc(cc);
    } else if (app.got_subcommand(crossover_cmd)) {
        uint8_t *data2; size_t size2;
        std::tie(data2, size2) = load_file(file2);
        if (size2 == 0) {
            delete [] data;
            return 1;
        }

        CallChain cc2(data2, size2);
        if (cc2.get_size() == 0) {
            std::cout << "Second chain is empty" << std::endl;
            delete [] data;
            delete [] data2;
            return 0;
        }

        size_t out_size = size + size2;
        uint8_t *out = new uint8_t[out_size];
        out_size = crossover(data, size, data2, size2, out, out_size, p1, p2);

        for (size_t i = 0; i < out_size; ++i)
            std::cout << out[i];

        delete [] data2;
        delete [] out;
    } else if (app.got_subcommand(remove_call_cmd)) {
        size = cc.remove_call(p1);

        for (size_t i = 0; i < size; ++i)
            std::cout << data[i];
    } else if (app.got_subcommand(insert_call_cmd)) {
        size = cc.insert_call(p2, p1, size + MUTATION_RESERVE);

        for (size_t i = 0; i < size; ++i)
            std::cout << data[i];
    } else if (app.got_subcommand(mutate_args_cmd)) {
        size = cc.mutate_args(p1);

        for (size_t i = 0; i < size; ++i)
            std::cout << data[i];
    }

    delete [] data;

    return 0;
}
