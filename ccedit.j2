/// This file is autogenerated

#include "{{ class_header }}"

#include <cstdint>
#include <iterator> // for std::size
#include <random>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <CLI11.hpp>

/// ------------------------------ DUMPED DATA ------------------------------

namespace target {

/// Structure representing argument
struct Argument {
    bool is_pointer;
    size_t size;
    const char *tname;
};

/// Max amount of arguments in a call
const size_t ARG_LIMIT = {{ arg_limit }};

/// Summarized data about arguments
struct AData {
    Argument list[ARG_LIMIT];
    size_t size;
    size_t bytesize;
};

/// -------------- CONSTRUCTORS --------------

/// Constructor data
struct CData {
    AData args;
    {{ class_name }} (*fn)(const uint8_t *);
};

{% for c in constructors %}
{{ class_name }} constr_{{ loop.index }}(const uint8_t *data) {
{% if length(c.args) == 0 %}    return {{ class_name }}();
{% else %}    size_t size = 0;

    {% for a in c.args -%}
    {{ a.name }} *arg_{{ loop.index }} = ({{ a.name }} *)(data + size);
    size += sizeof({{ a.name }});{% endfor %}

    return {{ class_name }}({% for a in c.args %}{% if loop.index != 0 %}, {% endif %}*arg_{{loop.index}}{% endfor %});
{% endif %}{{ "};" }}
{% endfor %}

/// List of all constructors info
const CData c_list[] = {
    {% for c in constructors -%}
    {
        .args = {
            .list = {
                {% for a in c.args %}{{ "{" }}{{ a.is_pointer }}, sizeof({{ a.name }}), "{{ a.name }}"},{% endfor %}
            },
            .size = {{ length(c.args) }},
            .bytesize = 0{% for a in c.args %} + sizeof({{ a.name }}){% endfor %},
        },
        .fn = constr_{{ loop.index }},
    },{% endfor %}
};

constexpr size_t c_size = std::size(c_list);

/// -------------- METHODS --------------

/// Method data
struct MData {
    AData args;
    const char *name;
    void (*fn)({{ class_name }} *, const uint8_t *);
};

{% for m in methods %}
void method_{{ loop.index }}({{ class_name }} *obj, const uint8_t *data) {
{% if length(m.args) == 0 %}    obj->{{ m.name }}();
{% else %}    size_t size = 0;

    {% for a in m.args -%}
    {{ a.name }} *arg_{{ loop.index }} = ({{ a.name }} *)(data + size);
    size += sizeof({{ a.name }});{% endfor %}

    obj->{{ m.name }}({% for a in m.args %}{% if loop.index != 0 %}, {% endif %}*arg_{{ loop.index }}{% endfor %});
{% endif %}{{ "};"}}
{% endfor %}

/// List of all method info
const MData m_list[] = {
    {% for m in methods -%}
    {
        .args = {
            .list = {
                {% for a in m.args %}{{ "{" }}{{ a.is_pointer }}, sizeof({{ a.name }}), "{{ a.name }}"},{% endfor %}
            },
            .size = {{ length(m.args) }},
            .bytesize = 0{% for a in m.args %} + sizeof({{ a.name }}){% endfor %},
        },
        .name = "{{ m.name }}",
        .fn = method_{{ loop.index }},
    },{% endfor %}
};

constexpr size_t m_size = std::size(m_list);

} // namespace

/// ------------------------------ CALL CHAIN AND MUTATOR ------------------------------

/**
 * This is class for working with Call Chains (mutations and other userful functions)
 * Note that parsing takes time and for simple classes it's better to used standart binary mutations
*/
class CallChain {
public:
    /// MAX amount of methods allowed (class uses static memory)
    static const size_t MLIMIT = {{ cc_limit }}; 

    /// Evaluate CC while reading
    static int eval(const uint8_t *data, size_t size) {
        if (size == 0)
            return 1;
        
        size_t ptr = 0;
        auto c = target::c_list[data[ptr] % target::c_size];
        ptr++;

        if (ptr + c.args.bytesize > size)
            return 1;

        auto obj = c.fn(data + ptr);
        ptr += c.args.bytesize;

        if (ptr == size) // CC with only constructor
            return 1;

        auto m = target::m_list[data[ptr] % target::m_size];
        ptr++;

        for (size_t i = 0; i < MLIMIT; ++i) {
            if (ptr + m.args.bytesize > size)
                break;
            
            m.fn(&obj, data + ptr);
            ptr += m.args.bytesize;

            if (ptr == size) // No room for method id
                return 1;
            
            m = target::m_list[data[ptr] % target::m_size];
            ptr++;
        }

        return 0;
    }

    CallChain(const uint8_t *data, size_t size) : d1(data), d2(nullptr), d_size(size) { update(); }
    
    CallChain(uint8_t *data, size_t size) : d1(data), d2(data), d_size(size) { update(); }

    inline bool is_const() const {
        return d2 == nullptr;
    }

    inline bool is_empty() const {
        return c_size == 0;
    }

    inline bool is_methodless() const {
        return m_size == 0;
    }

    /// Returns amount of methods (not counting constructor)
    inline size_t get_size() const {
        return m_size;
    }

    /// Get constructor id
    size_t get_cid() const {
        if (!is_empty())
            return d1[0] % target::c_size;
        throw std::logic_error("Attempt to get constructor id of an empty CC");
    }

    /// Get method id
    size_t get_mid(size_t n) const {
        if (!is_empty())
            return d1[m[n % m_size]] % target::m_size;
        throw std::logic_error("Attempt to get method id of an empty CC");
    }

    /// Is constructor argless
    bool is_c_argless() const {
        if (is_empty())
            throw std::logic_error("Attempt to check if constructor argless when there is no constructor");
        return c_size == 1;
    }

    /// Get arg bytearray for constructor
    std::tuple<const uint8_t *, size_t> get_c_arg(size_t arg_n) const {
        if (is_empty())
            throw std::logic_error("Attemplt to get constructor argument of an empty CC");

        auto c_args = target::c_list[d1[0] % target::c_size].args;

        if (c_args.size == 0)
            throw std::logic_error("Attempt to get contructor argument from a contructor with no arguments");

        arg_n %= c_args.size;
        
        size_t i, bytes = 1;
        for (i = 0; i < arg_n; ++i)
            bytes += c_args.list[i].size;
        
        return std::make_tuple(d1 + bytes, c_args.list[i].size);
    }

    bool is_m_argless(size_t n) const {
        if (is_methodless())
            throw std::logic_error("Attempt to check if method argless when there is no methods");
        auto m_args = target::m_list[d1[m[n % m_size]] % target::m_size].args;
        return m_args.size == 0; 
    }

    /// Get arg bytearray for method
    std::tuple<const uint8_t *, size_t> get_m_arg(size_t n, size_t arg_n) const {
        if (is_methodless())
            throw std::logic_error("Attemplt to get method argument of CC with no methods");

        n %= m_size;
        auto m_args = target::m_list[d1[m[n]] % target::m_size].args;

        if (m_args.size == 0)
            throw std::logic_error("Attempt to get method argument from a method with no arguments");

        arg_n %= m_args.size;
        
        size_t i, bytes = 1;
        for (i = 0; i < arg_n; ++i)
            bytes += m_args.list[i].size;
        
        return std::make_tuple(d1 + m[n] + bytes, m_args.list[i].size);
    }

    /// Get offset of method
    size_t get_m_offset(size_t n) const {
        if (is_empty())
            return 0;
        if (is_methodless())
            return c_size;
        
        return m[n % m_size];
    }

    /// Remove method from CC
    /// Returns new byte len
    size_t rm_m(size_t n) {
        if (is_empty() || is_methodless() || is_const())
            return d_size;

        n %= m_size;

        // If it's last then just cut it off
        if (n == m_size - 1) {
            d_size = m[n];
            m_size--;
            return d_size;
        }

        // Shift everything in d2
        size_t offset = m[n + 1] - m[n];
        for (size_t i = m[n + 1]; i < d_size; ++i)
            d2[i - offset] = d2[i];
        d_size -= offset;

        // Fix m array
        int shift = offset - (m[n + 1] - m[n]);
        for (size_t i = n + 1; i < m_size - 1; ++i)
            m[i] += offset;
        m_size--;

        return d_size;
    }

    /// Insert method
    /// Returns new byte length
    size_t ins_m(size_t n, size_t id, size_t max_size) {
        id %= target::m_size;
        size_t args = target::m_list[id].args.bytesize;
        if (is_empty() || is_const() || d_size + 1 + args > max_size)
            return d_size;
        
        // mod + 1 because we want to add methods to the start and end
        n = m_size == 0 ? 0 : n % (m_size + 1);

        // If it's last then it's simple
        if (n == m_size) {
            // Create new empty call
            d2[d_size] = id;
            for (size_t i = 0; i < args; ++i)
                d2[d_size + 1 + i] = 0;
            
            // Update class info
            m[m_size] = d_size;
            d_size += 1 + args;
            m_size++;

            return d_size;
        }
        
        // Shift everything
        for (size_t i = d_size - 1; i >= m[n]; --i)
            d2[i + 1 + args] = d2[i];
        
        // Set call
        d2[m[n]] = id;
        for (size_t i = 0; i < args; ++i)
            d2[m[n] + 1 + i] = 0;
                
        // Fix m array
        int offset = (1 + args) - (m[n + 1] - m[n]);
        for (size_t i = n + 1; i < m_size; ++i)
            m[i] += offset;
        m[m_size] = d_size;
        d_size += 1 + args;
        m_size++;

        return d_size;
    }

private:
    /// Source buffer data
    const uint8_t *d1;
    uint8_t *d2;
    size_t d_size;

    /// Constructor section length
    size_t c_size;

    // Method offsets
    size_t m[MLIMIT];
    size_t m_size;

    /// Update method data depending on d1
    void update() {
        m_size = 0;
        c_size = 0;

        if (d_size == 0)
            return;

        size_t offset = 1 + target::c_list[d1[0] % target::c_size].args.bytesize;
        if (offset > d_size)
            return;
        
        c_size = offset;
        
        size_t ptr;
        for (ptr = offset; ptr < d_size && m_size < MLIMIT; ++m_size) {
            m[m_size] = ptr;
            ptr += 1 + target::m_list[d1[ptr] % target::m_size].args.bytesize;
        }
        if (ptr != d_size) // Check if we have incomplete call
            m_size--;
    }
};

//     size_t mutate_args(size_t n) {
//         if (d2 == nullptr)
//             return d_size;
        
//         uint8_t *data = d2 + calls[n - 1] + 1;
//         size_t size = calls[n] - calls[n - 1];

//         // Simulate libfuzzer modifications
//         for (size_t i = 0; i < size; ++i)
//             data[i] = 'a';

//         return d_size;
//     }

/// ------------------------------ MUTATOR FNs ------------------------------

std::tuple<uint8_t *, size_t> crossover(
    const uint8_t *data1, size_t size1,
    const uint8_t *data2, size_t size2,
    size_t n1, size_t n2
) {
    CallChain cc1(data1, size1), cc2(data2, size2);

    if (cc1.is_empty() || cc2.is_methodless()) {
        uint8_t *data = new uint8_t[size1];
        for (size_t i = 0; i < size1; ++i)
            data[i] = data1[i];
        return std::make_tuple(data, size1);
    }

    // Mod with +1 is because:
    // 0 - we take constructor only
    // cc1.get_size() - we take whole CC
    n1 %= (cc1.get_size() + 1);

    // Here we take methods from p2 to cc2.get_size()
    // Note that we can't take 0 methods
    n2 %= cc2.get_size();

    size_t size = n1 + (size2 - n2);
    uint8_t *data = new uint8_t[size];

    size_t limit = n1 == cc1.get_size() ? size1 : cc1.get_m_offset(n1);
    size_t i;
    for (i = 0; i < limit; ++i)
        data[i] = data1[i];
    
    for (size_t j = cc2.get_m_offset(n2); j < size2; ++j, ++i)
        data[i] = data2[j];

    return std::make_tuple(data, size);
}

/// ------------------------------ PRINT FNs ------------------------------

void print_class_fns() {
    for (size_t i = 0; i < target::c_size; ++i, std::cout << ")" << std::endl) {
        std::cout << i << " {{ class_name }}(";
        if (target::c_list[i].args.size == 0) // Prevent underflow in for
            continue;
            
        size_t last = target::c_list[i].args.size;
        for (size_t j = 0; j < last - 1; ++j)
            std::cout << target::c_list[i].args.list[j].tname << "(" << target::c_list[i].args.list[j].size << ")" << ", ";
        std::cout << target::c_list[i].args.list[last - 1].tname << "(" << target::c_list[i].args.list[last - 1].size << ")";
    }

    std::cout << std::endl;

    for (size_t i = 0; i < target::m_size; ++i, std::cout << ")" << std::endl) {
        std::cout << i << " " << target::m_list[i].name << "(";
        if (target::m_list[i].args.size == 0)
            continue;
        
        size_t last = target::m_list[i].args.size;
        for (size_t j = 0; j < last - 1; ++j)
            std::cout << target::m_list[i].args.list[j].tname << "(" << target::m_list[i].args.list[j].size << ")" << ", ";
        std::cout << target::m_list[i].args.list[last - 1].tname << "(" << target::m_list[i].args.list[last - 1].size << ")";
    }
}

void print_hex(const uint8_t *data, size_t size) {
    for (size_t i = 0; i < size; ++i)
        std::cout << std::hex << std::setfill('0') << std::setw(2) << (int)data[i];
}

void print_raw(uint8_t *data, size_t size) {
    for (size_t i = 0; i < size; ++i)
        std::cout << (char)data[i];
}

void print_cc(CallChain &cc) {
    std::cout << "Total " << cc.get_size() << " calls" << std::endl << std::endl;
    std::cout << "n start id call" << std::endl << "--------------" << std::endl;

    size_t cid = cc.get_cid();
    std::cout << "- 0 " << cid << " {{ class_name }}(";

    if (cc.is_c_argless()) {}
    else {
        auto c_args = target::c_list[cid].args;
        for (size_t i = 0; i < c_args.size; ++i) {
            std::cout << std::endl << "    " << c_args.list[i].tname << " : ";
            
            const uint8_t *a_data;
            size_t a_size;
            std::tie(a_data, a_size) = cc.get_c_arg(i);

            print_hex(a_data, a_size);
            std::cout << std::endl;
        }
    }
    std::cout << ")" << std::endl;

    for (size_t i = 0; i < cc.get_size(); ++i) {
        cid = cc.get_mid(i);
        std::cout << std::dec << i << " " << cc.get_m_offset(i) << " " << cid << " " << target::m_list[cid].name << "(";

        if (cc.is_m_argless(i)) {}
        else {
            auto m_args = target::m_list[cid].args;
            for (size_t j = 0; j < m_args.size; ++j) {
                std::cout << std::endl << "    " << m_args.list[j].tname << " : ";
            
                const uint8_t *a_data;
                size_t a_size;
                std::tie(a_data, a_size) = cc.get_m_arg(i, j);

                print_hex(a_data, a_size);
                std::cout << std::endl;
            }
        }
        std::cout << ")" << std::endl;
    }
}
/// ------------------------------ LOAD FNs ------------------------------

const size_t MUTATION_RESERVE = 100; // In bytes

/// Sets pointer to nullptr on error 
std::tuple<uint8_t *, size_t> load_file(const std::string &filename) {
    std::ifstream ifs(filename);
    if (!ifs)
        return std::make_tuple(nullptr, 0);

    ifs.seekg(0, std::ios_base::end);
    std::streamsize size = ifs.tellg();
    ifs.seekg(0, std::ios_base::beg);

    uint8_t *data = new uint8_t[size + MUTATION_RESERVE];
    if (!ifs.read(reinterpret_cast<char*>(data), size)) {
        delete [] data;
        return std::make_tuple(nullptr, 0);
    }

    return std::make_tuple(data, size);
}

/// Sets pointer to nullptr on error
std::tuple<uint8_t *, size_t> load_hex(const std::string &hexstr) {
    if (hexstr.size() % 2 != 0)
        return std::make_tuple(nullptr, 0);
    
    size_t size = hexstr.size() / 2;
    uint8_t *data = new uint8_t[size + MUTATION_RESERVE];
    std::string tmp;
    for (size_t i = 0; i < size; ++i) {
        tmp = hexstr.substr(i * 2, 2);
        data[i] = std::strtol(tmp.c_str(), NULL, 16);
    }

    return std::make_tuple(data, size);
}

/// ------------------------------ MAIN FN ------------------------------

enum class CCOutFormat : int { Hex, Raw, Printable, Quiet };

int main(int argc, char **argv) {
    CLI::App app("CallChain editor");
    argv = app.ensure_utf8(argv);

    std::string file_in, hex_in;
    bool dump_class(false);
    auto cc_option = app.add_option_group("Call Chain (CC)", "Input CC to work with");
    cc_option->add_option("-f,--file", file_in, "Load from file")->check(CLI::ExistingFile);
    cc_option->add_option("-x,--hex", hex_in, "Load from hex");
    cc_option->add_flag("-d,--dump-class", dump_class, "Print class info");
    cc_option->require_option(1);

    std::string file_in2, hex_in2;
    size_t n1, n2;
    auto crossover_cmd = app.add_subcommand("crossover", "Crossover two CC's");
    auto co_cc_option = crossover_cmd->add_option_group("Second CC", "Second CC to crossover with");
    co_cc_option->add_option("-f,--file", file_in2, "Load from file")->check(CLI::ExistingFile);
    co_cc_option->add_option("-x,--hex", hex_in2, "Load from hex");
    co_cc_option->require_option(1);
    auto co_n1_option = crossover_cmd->add_option("-1,--n1", n1, "Point to cut of first chain (takes all before p1)");
    auto co_n2_option = crossover_cmd->add_option("-2,--n2", n2, "Point to continue second chain (takes all starting from p2)");

    auto rm_cmd = app.add_subcommand("rm", "Remove method from CC");
    auto rm_n_option = rm_cmd->add_option("-n", n1, "Remove n-th method (starting from zero)");

    auto ins_cmd = app.add_subcommand("ins", "Insert method into CC (all args get zeroed)");
    ins_cmd->add_option("-n", n1, "Add method to the n-th place")->default_val(0);
    auto ins_c_option = ins_cmd->add_option("-c", n2, "Call id");

    auto seta_cmd = app.add_subcommand("seta", "Set argument(s) of the call");
    // TODO: make setter usable
    
    auto swap_cmd = app.add_subcommand("swap", "Swap two calls");
    swap_cmd->add_option("-1,--n1", n1, "First call id to swap with");
    swap_cmd->add_option("-2,--n2", n2, "Second call id to swap with");
    
    auto dup_cmd = app.add_subcommand("dup", "Duplicate call");
    dup_cmd->add_option("-1,--n1", "Which call duplicate");
    dup_cmd->add_option("-2,--n2", "Position of the duplicated call");

    bool eval(false);
    auto eval_option = app.add_flag("-e,--eval", eval, "Evaluate CC after all modifications");

    CCOutFormat out_mode;
    std::map<std::string, CCOutFormat> out_format_map{
        {"h", CCOutFormat::Hex},
        {"r", CCOutFormat::Raw},
        {"p", CCOutFormat::Printable},
        {"q", CCOutFormat::Quiet}
    };
    auto out_format_option = app.add_option("-o,--out", out_mode, "Output format")
        ->default_val(CCOutFormat::Printable)
        ->transform(CLI::CheckedTransformer(out_format_map, CLI::ignore_case).description("Output format"));

    CLI11_PARSE(app, argc, argv);

    // Print all class data indexed
    if (dump_class) {
        print_class_fns();
        return 0;
    }

    // Load
    uint8_t *data; size_t size;
    if (!file_in.empty())
        std::tie(data, size) = load_file(file_in);
    else
        std::tie(data, size) = load_hex(hex_in);
    if (data == nullptr) {
        std::cerr << "Loading error" << std::endl;
        return 1;
    }
    CallChain cc(data, size);

    // Init random if needed
    std::random_device rd;
    std::mt19937 rng(rd());

    // CLI11 can't give out repeated subcommands so we process one at the time
    if (app.got_subcommand(crossover_cmd)) {
        // Load data2
        uint8_t *data2; size_t size2;
        if (!file_in2.empty())
            std::tie(data2, size2) = load_file(file_in2);
        else
            std::tie(data2, size2) = load_hex(hex_in2);
        if (data2 == nullptr) {
            std::cerr << "CO Loading error" << std::endl;
            delete [] data;
            return 1;
        }

        // Randomize n1, n2 if needed
        if (co_n1_option->count() == 0)
            n1 = rng();
        if (co_n2_option->count() == 0)
            n2 = rng();
        
        uint8_t *result; size_t result_size;
        std::tie(result, result_size) = crossover(data, size, data2, size2, n1, n2);

        // We want output of result so
        delete [] data;
        delete [] data2;
        data = result; // for later free purposes
        size  = result_size;
        cc = CallChain(result, result_size);

    } else if (app.got_subcommand(rm_cmd)) {
        // Randomize n if not set
        if (rm_n_option->count() == 0)
            n1 = rng();
        
        size = cc.rm_m(n1);
    } if (app.got_subcommand(ins_cmd)) {
        // If call id not set then use random
        if (ins_c_option->count() == 0)
            n2 = rng();
        
        size = cc.ins_m(n1, n2, size + MUTATION_RESERVE);
    } else {
        // TODO: other subcommands
    }

    // Print output
    switch (out_mode) {
        case CCOutFormat::Hex: {
            print_hex(data, size);
            std::cout << std::endl;
            break;
        }
        case CCOutFormat::Printable: {
            print_cc(cc);
            break;
        }
        case CCOutFormat::Raw: {
            print_raw(data, size);
            break;
        }
        case CCOutFormat::Quiet: {
            break;
        }
        default: throw std::logic_error("Unknown CCOutFormat type");
    }

    // Evaluate
    if (eval)
        CallChain::eval(data, size);

    // Free
    delete [] data;

    return 0;
}
